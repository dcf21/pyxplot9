% programming.tex
%
% The documentation in this file is part of PyXPlot
% <http://www.pyxplot.org.uk>
%
% Copyright (C) 2006-2012 Dominic Ford <coders@pyxplot.org.uk>
%               2008-2012 Ross Church
%
% $Id$
%
% PyXPlot is free software; you can redistribute it and/or modify it under the
% terms of the GNU General Public License as published by the Free Software
% Foundation; either version 2 of the License, or (at your option) any later
% version.
%
% You should have received a copy of the GNU General Public License along with
% PyXPlot; if not, write to the Free Software Foundation, Inc., 51 Franklin
% Street, Fifth Floor, Boston, MA  02110-1301, USA

% ----------------------------------------------------------------------------

% LaTeX source for the PyXPlot Users' Guide

\chapter{Programming: PyXPlot's data types}

In this chapter we describe the facilities which PyXPlot has for automating
repetitive tasks. We begin by introducing string variables, which can be useful
for auto-generating titles and labels for graphs which are being produced in
batch jobs. We then discuss the loop constructs which make it possible to run
such batch jobs, producing similar plots of many different \datafile s or
performing calculations in an iterative fashion. Finally, we turn to PyXPlot's
interaction with the shell and filing system in which it operates, introducing
a simple framework for automatically re-executing PyXPlot scripts whenever they
change, allowing plots to be automatically regenerated whenever the scripts
used to produce them are modified.

\section{Strings}
\label{sec:stringvars}
\index{variables!string}

Variables may hold not only numerical quantities, but also strings of text.  In
the course of this chapter, we will see several examples where string variables
are used either to generate automatic labels for graphs plotted in batch jobs,
or to read strings of text from columns of \datafile s. String variables can be
assigned in a analogous manner to numeric variables, and can subsequently be
used anywhere where a quoted string could have been used, as in the example:
\begin{verbatim}
plotname = "Insert title here"
set title plotname
\end{verbatim}

\subsection{The string substitution operator}
\label{sec:stringsubop}

Most string manipulations are performed using the string substitution operator,
{\tt \%}\index{\% operator@{\tt \%} operator}. This operator should be
preceded by a format string, such as {\tt x=\%f}, in which tokens such as {\tt
\%f} mark places where numbers and strings should be substituted. The
substitution operator is followed by a bracketed list of the quantities which
should be substituted in place of these tokens in the format string. This
behaviour is similar to that of the Python programming language's \%
operator\footnote{Unlike in Python, the brackets are obligatory; {\tt '\%d'\%2}
is {\it not} valid in PyXPlot, and should be written as {\tt '\%d'\%(2)}.} and
of the {\tt printf} statement in C.  For example, to concatenate the two
strings contained in the variables {\tt a} and {\tt b} into a single string
variable {\tt c}, one would issue the command:\index{string
operators!concatenation}
\begin{verbatim}
c = "%s%s"%(a,b)
\end{verbatim}

One application of this operator might be to label plots with the title of the
\datafile\ being plotted, as in the following example:
\begin{verbatim}
filename="data_file.dat"
title="A plot of the data in {\tt %s}."%(filename)
set title title
plot filename
\end{verbatim}

The syntax of the substitution tokens placed in the format string is similar to
that used by many other languages and is as follows. All substitution tokens
begin with a {\tt \%} character, after which there may be placed, in order:

\begin{enumerate}
\item An optional minus sign, to specify that the substituted item should be left-justified.
\item An optional integer specifying the minimum character width of the substituted item, or a {\tt *} (see below).
\item An optional decimal point/period ({\tt .}) separator.
\item An optional integer, or a {\tt *} (see below), specifying either (a) the maximum number of characters to be printed from a string, or (b) the number of decimal places of a floating-point number to be displayed, or (c) the minimum number of digits of an integer to be displayed, padded to the left with zeros.
\item A conversion character.
\end{enumerate}

\noindent The conversion character is a single character which specifies what
kind of substitution should take place. Its possible values are listed in
Table~\ref{tab:conversion_chars}. Note that where numerical quantities with
physical units are provided, the physical units are not displayed unless the
{\tt \%s} token is used. Although it is not an error to pass a quantity with
physical units to, for example, the {\tt \%f} substitution token, it is good
practice to divide the quantity by a suitable unit first to make it
dimensionless, to be certain of the unit in which it will be displayed.

\begin{table}
\begin{center}
\begin{tabular}{|>{\columncolor{LightGrey}}l>{\columncolor{LightGrey}}p{9cm}|}
\hline
{\bf Character} & {\bf Substitutes} \\
\hline
{\tt d}, {\tt i}   & An integer value. \\
{\tt e}, {\tt E}   & A floating-point value in scientific notation using either the character {\tt e} or {\tt E} to indicate exponentiation. \\
{\tt f}            & A floating-point value without the use of scientific notation. \\
{\tt g}, {\tt G}   & A floating-point value, either using scientific notation, if the exponent is greater than the precision or less than $-4$, otherwise without the use of scientific notation. \\
{\tt o}            & An integer value in octal (base~8). \\
{\tt s}, {\tt S}, {\tt c} & A string, if a string is provided, or a numerical quantity, with units, if such is provided. \\
{\tt x}, {\tt X}   & An integer value in hexadecimal (base~16). \\
{\tt \%}           & A literal {\tt \%} sign. \\
\hline
\end{tabular}
\end{center}
\caption{The conversion characters recognised by the string substitution operator, {\tt \%}.}
\label{tab:conversion_chars}
\end{table}

Where the character {\tt *} is specified for either the character width or the
precision of the substitution token, an integer is read from the list of items
to be substituted, as happens in C's {\tt printf} command:

\vspace{3mm}
\input{fragments/tex/prog_stringsub.tex}
\vspace{3mm}

\subsection{Regular expressions}

String variables can be modified using the search-and-replace string
operator\index{string operators!search and replace}\footnote{Programmers with
experience of {\tt perl} will recognise this syntax.}, =$\sim$\index{=$\sim$
operator}, which takes a regular expression with a syntax similar to that
expected by the shell command {\tt sed}\index{sed shell command@{\tt sed} shell
command} and applies it to the relevant string variable.\footnote{Regular
expression syntax is a massive subject, and is beyond the scope of this manual.
The official GNU documentation for the {\tt sed} command is heavy reading, but
there are many more accessible tutorials on the web.}\index{regular
expressions} In the following example, the first instance of the letter {\tt s} in
the string variable {\tt twister} is replaced with the letters {\tt th}:

\vspace{3mm}
\input{fragments/tex/prog_re1.tex}
\vspace{3mm}

Note that only the {\tt s} (substitute) command of {\tt sed} is implemented in
PyXPlot. Any character can be used in place of the {\tt /} characters in the
above example, for example:

\begin{verbatim}
twister =~ s's'th'
\end{verbatim}

\noindent Flags can be passed, as in {\tt sed} or {\tt perl}, to modify the
precise behaviour of the regular expression. In the following example the {\tt
g} flag is used to perform a global search-and-replace of all instances of the
letter {\tt s} with the letters {\tt th}:

\vspace{3mm}
\input{fragments/tex/prog_re2.tex}
\vspace{3mm}

\noindent Table~\ref{tab:re_flags} lists all of the regular expression flags
recognised by the =$\sim$ operator.

\begin{table}
{\footnotesize
\begin{tabular}{|>{\columncolor{LightGrey}}p{5mm}>{\columncolor{LightGrey}}p{10.5cm}|}
\hline
{\tt g} & Replace {\it all} matches of the pattern; by default, only the first match is replaced. \\
{\tt i} & Perform case-insensitive matching, such that expressions like {\tt [A-Z]} will match lowercase letters, too. \\
{\tt l} & Make {\tt $\backslash$w}, {\tt $\backslash$W}, {\tt $\backslash$b}, {\tt $\backslash$B}, {\tt $\backslash$s} and {\tt $\backslash$S} dependent on the current locale. \\
{\tt m} & When specified, the pattern character {\tt \^{}} matches the beginning of the string and the beginning of each line immediately following each newline. The pattern character {\tt \$} matches at the end of the string and the end of each line immediately preceding each newline. By default, {\tt \^{}} matches only the beginning of the string, and {\tt \$} only the end of the string and immediately before the newline, if present, at the end of the string. \\
{\tt s} & Make the {\tt .} special character match any character at all, including a newline; without this flag, {\tt .} will match anything except a newline. \\
{\tt u} & Make {\tt $\backslash$w}, {\tt $\backslash$W}, {\tt $\backslash$b}, {\tt $\backslash$B}, {\tt $\backslash$s} and {\tt $\backslash$S} dependent on the Unicode character properties database. \\
{\tt x} & This flag allows the user to write regular expressions that look nicer. Whitespace within the pattern is ignored, except when in a character class or preceded by an un-escaped backslash. When a line contains a {\tt \#}, neither in a character class nor preceded by an un-escaped backslash, all characters from the left-most such {\tt \#} through to the end of the line are ignored. \\
\hline
\end{tabular}}
\caption{A list of the flags accepted by the =$\sim$ operator. Most are rarely used, but the {\tt g} flag is very useful.}
\label{tab:re_flags}
\end{table}

\subsection{String manipulation methods}

The following functions are provided for performing simple manipulations upon
strings:

\noindent
\begin{itemize}
\item {\tt strcmp(s1,s2)}\indfun{strcmp($s1,s2$)} returns zero if the strings {\tt s1} and {\tt s2} are the same, one if {\tt s1} should be placed after {\tt s2} in alphabetical sequence, minus one if {\tt s1} should be placed before {\tt s2} in alphabetical sequence.
\item {\tt strlen(s)}\indfun{strlen($s$)} returns the integer length of the string variable {\tt s}. An error is returned if {\tt s} is not a string variable.
\item {\tt strlower(s)}\indfun{strlower($s$)} returns a version of the string {\tt s} in which all uppercase alphabetical characters are converted to lowercase characters.
\item {\tt strrange(s,i,j)}\indfun{strrange($s,i,j$)} returns a slice of the string $s$, containing only the $i$th through until the $j$th characters of the string. If either $i$ or $j$ are negative, they are counted from the end of the string; for example, $-1$ refers to the last character of the string.
\item {\tt strupper(s)}\indfun{strupper($s$)} returns a version of the string {\tt s} in which all lowercase alphabetical characters are converted to uppercase characters.
\end{itemize}

\noindent
The following simple examples demonstrate the use of these functions:

\vspace{3mm}
\input{fragments/tex/prog_stringmethods.tex}
\vspace{3mm}

\vspace{3mm}
\input{fragments/tex/prog_stringmethods2.tex}
\vspace{3mm}

\section{Lists}

\section{Dictionaries}

\section{Vectors and matrices}

\section{Colors}

\section{Dates}

\section{Modules and classes}
