% programming.tex
%
% The documentation in this file is part of PyXPlot
% <http://www.pyxplot.org.uk>
%
% Copyright (C) 2006-2012 Dominic Ford <coders@pyxplot.org.uk>
%               2008-2012 Ross Church
%
% $Id$
%
% PyXPlot is free software; you can redistribute it and/or modify it under the
% terms of the GNU General Public License as published by the Free Software
% Foundation; either version 2 of the License, or (at your option) any later
% version.
%
% You should have received a copy of the GNU General Public License along with
% PyXPlot; if not, write to the Free Software Foundation, Inc., 51 Franklin
% Street, Fifth Floor, Boston, MA  02110-1301, USA

% ----------------------------------------------------------------------------

% LaTeX source for the PyXPlot Users' Guide

\chapter{Programming: PyXPlot's data types}
\label{chap:progDataTypes}

This chapter describes PyXPlot's data types such as lists, dictionaries,
vectors, matrices and file handles.  In each case, we illustrate how each data
type interfaces with PyXPlot's graph plotting and vector graphics environment.

\section{Strings}
\label{sec:stringvars}
\index{variables!string}

Strings can be enclosed either in single ({\tt '}) or double ({\tt "}) quotes.
Strings may also be enclosed by three quote characters in a row: either {\tt
'''} or {\tt """}. Special care needs to be taken when using apostrophes or
quotes in single-quote delimited strings, as these characters may be
misinterpreted as string delimiters, as in the example:

\begin{dontdo}
'Robert's data'
\end{dontdo}

\noindent This easiest way to avoid such problems is to use three quotes:

\begin{dodo}
'''Robert's data'''
\end{dodo}

Special characters such as tabs and newlines can be inserted into strings using
escape codes such as {\tt $\backslash$t} and {\tt $\backslash$n}; see
Table~\ref{tab:escape_sequences2} for a list of these. The following string is
split over three lines:

\vspace{3mm}
\input{fragments/tex/fs_print4.tex}
\vspace{3mm}

Sometimes these escape codes can be rather annoying, especially when entering
\LaTeX control codes, which all begin with backslash characters. Rather than
having to escape every backslash, it is generally easier to prefix the string
with the character {\tt r}, which turns off all escape codes:

\vspace{3mm}
\input{fragments/tex/fs_print5.tex}
\vspace{3mm}

\begin{table}
\begin{center}
\begin{tabular}{|>{\columncolor{LightGrey}}l>{\columncolor{LightGrey}}l|}
\hline
{\bf Escape sequence} & {\bf Description} \\
\hline
{\tt $\backslash$?} & Question mark \\
{\tt $\backslash$'} & Apostrophe \\
{\tt $\backslash$"} & Double quote \\
{\tt $\backslash\backslash$} & Literal backslash \\
{\tt $\backslash$a} & Bell character \\
{\tt $\backslash$b} & Backspace \\
{\tt $\backslash$f} & Formfeed \\
{\tt $\backslash$n} & Newline \\
{\tt $\backslash$r} & Carriage return \\
{\tt $\backslash$t} & Horizontal tab \\
{\tt $\backslash$v} & Vertical tab \\
\hline
\end{tabular}
\end{center}
\caption{A complete list of PyXPlot's string escape sequences. These are a subset of those available in C.}
\label{tab:escape_sequences2}
\end{table}

Once defined, a string variable can be used anywhere in PyXPlot where a quoted
string could have been used, for example in the {\tt set title} command:

\begin{verbatim}
plotname = "Insert title here"
set title plotname
\end{verbatim}

\subsection{The string substitution operator}
\label{sec:stringsubop}

Most string manipulations are performed using the string substitution operator,
{\tt \%}\index{\% operator@{\tt \%} operator}. This operator should be preceded
by a format string, such as {\tt x=\%f}, in which tokens such as {\tt \%f} mark
places where numbers and strings should be substituted. The substitution
operator is followed by a bracketed list of the quantities which should be
substituted in place of these tokens in the format string. This behaviour is
similar to that of the Python programming language's \% operator\footnote{As in
Python, the brackets are optional when only one item is being substituted. For
example, {\tt '\%d'\%2} is equivalent to {\tt '\%d'\%(2)}.} and of the {\tt
printf} statement in C.  For example, to concatenate the two strings contained
in the variables {\tt a} and {\tt b} into a single string variable {\tt c}, one
would issue the command:\index{string operators!concatenation}

\begin{verbatim}
c = "%s%s"%(a,b)
\end{verbatim}

One application of this operator might be to label plots with the title of the
\datafile\ being plotted, as in the following example:
\begin{verbatim}
filename="data_file.dat"
title=r"A plot of the data in {\tt %s}."%(filename)
set title title
plot filename
\end{verbatim}

The syntax of the substitution tokens placed in the format string is similar to
that used by many other languages and is as follows. All substitution tokens
begin with a {\tt \%} character, after which there may be placed, in order:

\begin{enumerate}
\item An optional minus sign, to specify that the substituted item should be left-justified.
\item An optional integer specifying the minimum character width of the substituted item, or a {\tt *} (see below).
\item An optional decimal point/period ({\tt .}) separator.
\item An optional integer, or a {\tt *} (see below), specifying either (a) the maximum number of characters to be printed from a string, or (b) the number of decimal places of a floating-point number to be displayed, or (c) the minimum number of digits of an integer to be displayed, padded to the left with zeros.
\item A conversion character.
\end{enumerate}

\noindent The conversion character is a single character which specifies what
kind of substitution should take place. Its possible values are listed in
Table~\ref{tab:conversion_chars}. Note that where numerical quantities with
physical units are provided, the physical units are not displayed unless the
{\tt \%s} token is used. Although it is not an error to pass a quantity with
physical units to, for example, the {\tt \%f} substitution token, it is good
practice to divide the quantity by a suitable unit first to make it
dimensionless, to be certain of the unit in which it will be displayed.

\begin{table}
\begin{center}
\begin{tabular}{|>{\columncolor{LightGrey}}l>{\columncolor{LightGrey}}p{9cm}|}
\hline
{\bf Character} & {\bf Substitutes} \\
\hline
{\tt d}, {\tt i}   & An integer value. \\
{\tt e}, {\tt E}   & A floating-point value in scientific notation using either the character {\tt e} or {\tt E} to indicate exponentiation. \\
{\tt f}            & A floating-point value without the use of scientific notation. \\
{\tt g}, {\tt G}   & A floating-point value, either using scientific notation, if the exponent is greater than the precision or less than $-4$, otherwise without the use of scientific notation. \\
{\tt o}            & An integer value in octal (base~8). \\
{\tt s}, {\tt S}, {\tt c} & A string, if a string is provided, or a numerical quantity, with units, if such is provided. \\
{\tt x}, {\tt X}   & An integer value in hexadecimal (base~16). \\
{\tt \%}           & A literal {\tt \%} sign. \\
\hline
\end{tabular}
\end{center}
\caption{The conversion characters recognised by the string substitution operator, {\tt \%}.}
\label{tab:conversion_chars}
\end{table}

Where the character {\tt *} is specified for either the character width or the
precision of the substitution token, an integer is read from the list of items
to be substituted, as happens in C's {\tt printf} command:

\vspace{3mm}
\input{fragments/tex/prog_stringsub.tex}
\vspace{3mm}

\subsection{Slicing strings}



\subsection{String methods}

All objects in PyXPlot have {\tt methods}, which may be called, as in most object-orientated programming languages, by following the name of the object to be acted upon by a dot:

\begin{verbatim}
print "hello".upper()
print "hello".methods()
\end{verbatim}

\noindent All objects in PyXPlot have a method called {\tt methods()}, which returns a list of the names of all of that objects methods. Methods are like functions in that printing them returns brief documentation about them:

\vspace{3mm}
\input{fragments/tex/prog_methods.tex}
\vspace{3mm}

\noindent Descriptions of all of the methods of string objects can be found in Section~\ref{sec:string_methods}; in addition, a list of the methods that are common to all PyXPlot objects can be found in Section~\ref{sec:common_methods}.

The following simple examples demonstrate the use of some of them:

\vspace{3mm}
\input{fragments/tex/prog_stringmethods.tex}
\vspace{3mm}

\vspace{3mm}
\input{fragments/tex/prog_stringmethods2.tex}
\vspace{3mm}

\subsection{Regular expressions}

String variables can be modified using the search-and-replace string
operator\index{string operators!search and replace}\footnote{Programmers with
experience of {\tt perl} will recognise this syntax.}, =$\sim$\index{=$\sim$
operator}, which takes a regular expression with a syntax similar to that
expected by the shell command {\tt sed}\index{sed shell command@{\tt sed} shell
command} and applies it to the relevant string variable.\footnote{Regular
expression syntax is a massive subject, and is beyond the scope of this manual.
The official GNU documentation for the {\tt sed} command is heavy reading, but
there are many more accessible tutorials on the web.}\index{regular
expressions} In the following example, the first instance of the letter {\tt s} in
the string variable {\tt twister} is replaced with the letters {\tt th}:

\vspace{3mm}
\input{fragments/tex/prog_re1.tex}
\vspace{3mm}

Note that only the {\tt s} (substitute) command of {\tt sed} is implemented in
PyXPlot. Any character can be used in place of the {\tt /} characters in the
above example, for example:

\begin{verbatim}
twister =~ s's'th'
\end{verbatim}

\noindent Flags can be passed, as in {\tt sed} or {\tt perl}, to modify the
precise behaviour of the regular expression. In the following example the {\tt
g} flag is used to perform a global search-and-replace of all instances of the
letter {\tt s} with the letters {\tt th}:

\vspace{3mm}
\input{fragments/tex/prog_re2.tex}
\vspace{3mm}

\noindent Table~\ref{tab:re_flags} lists all of the regular expression flags
recognised by the =$\sim$ operator.

\begin{table}
{\footnotesize
\begin{tabular}{|>{\columncolor{LightGrey}}p{5mm}>{\columncolor{LightGrey}}p{10.5cm}|}
\hline
{\tt g} & Replace {\it all} matches of the pattern; by default, only the first match is replaced. \\
{\tt i} & Perform case-insensitive matching, such that expressions like {\tt [A-Z]} will match lowercase letters, too. \\
{\tt l} & Make {\tt $\backslash$w}, {\tt $\backslash$W}, {\tt $\backslash$b}, {\tt $\backslash$B}, {\tt $\backslash$s} and {\tt $\backslash$S} dependent on the current locale. \\
{\tt m} & When specified, the pattern character {\tt \^{}} matches the beginning of the string and the beginning of each line immediately following each newline. The pattern character {\tt \$} matches at the end of the string and the end of each line immediately preceding each newline. By default, {\tt \^{}} matches only the beginning of the string, and {\tt \$} only the end of the string and immediately before the newline, if present, at the end of the string. \\
{\tt s} & Make the {\tt .} special character match any character at all, including a newline; without this flag, {\tt .} will match anything except a newline. \\
{\tt u} & Make {\tt $\backslash$w}, {\tt $\backslash$W}, {\tt $\backslash$b}, {\tt $\backslash$B}, {\tt $\backslash$s} and {\tt $\backslash$S} dependent on the Unicode character properties database. \\
{\tt x} & This flag allows the user to write regular expressions that look nicer. Whitespace within the pattern is ignored, except when in a character class or preceded by an un-escaped backslash. When a line contains a {\tt \#}, neither in a character class nor preceded by an un-escaped backslash, all characters from the left-most such {\tt \#} through to the end of the line are ignored. \\
\hline
\end{tabular}}
\caption{A list of the flags accepted by the =$\sim$ operator. Most are rarely used, but the {\tt g} flag is very useful.}
\label{tab:re_flags}
\end{table}

\section{Lists}

List objects hold ordered sequencies of other PyXPlot objects, which may
include lists and dictionaries to create hierarchical data structures. They are
created by enclosing a comma-separated list of objects by square brackets:

\begin{verbatim}
a = [1,2,3,"fourth item"]
\end{verbatim}

Once created, more items can be added to a list using its {\tt append(item)}
and {\tt insert(n,item)} methods, where the latter inserts an item at position
$n$:

\vspace{3mm}
\input{fragments/tex/prog_listappend.tex}
\vspace{3mm}

\noindent
A complete list of the methods available on lists (itself a list of strings)
can be found by calling the method {\tt [].methods()}; they are also listed in
Section~\ref{sec:list_methods}. As with string methods, documentation of list
methods is returned if the method object is printed:

\vspace{3mm}
\input{fragments/tex/prog_listmethods.tex}
\vspace{3mm}

Most methods that operate on lists, for example, append, extend and sort
operations, return the list as their output. Unless this is stored in a
variable, PyXPlot prints this return value to the terminal. In some cases this
is useful: in the example above, it allowed us to see how the list was changing
when we called its {\tt append()} and {\tt insert()} methods. Often, however,
this terminal spam is unwanted. The \indcmdt{call} allows methods to be called
without printing their output, which is discarded:

\vspace{3mm}
\input{fragments/tex/prog_listappend2.tex}
\vspace{3mm}

The following example demonstrates the use of a list as a stack; note that the
last item added to the stack is the first one to be popped:

\vspace{3mm}
\input{fragments/tex/prog_liststack.tex}
\vspace{3mm}

Methods are provided for sorting data in lists. The {\tt sort()} method simply
sorts the members of a list into order of ascending value\footnote{Non-numeric
items are assigned arbitrary but consistent values for the purposes of sorting.
Booleans are always lower-valued than numbers, but numbers are lower-valued
than lists. Longer lists are always higher valued than shorter lists; larger
dictionaries are always higher-valued than smaller dictionaries.} The {\tt
sortOnElement(n)} method sorts a list of lists on the $n$th sub-element of each
sublist.

\vspace{3mm}
\input{fragments/tex/prog_listsort.tex}
\vspace{3mm}

The \indcmdt{foreach} command can be used to loop over the members of a list.
Data from lists can also be plotted onto graphs, but the list must first be
converted into a vector. See~\ref{sec:vectors} for more information.

\section{Dictionaries}

\section{Vectors and matrices}
\label{sec:vectors}

\section{Colors}

Most of PyXPlot's graph plotting and vector graphics commands have settings for
specifying colors. A selection of widely-used colors may be specified by name,
for example {\tt red} and {\tt blue}. However, greater freedom in choice of
color is available by passing these commands objects of type {\tt color}.

Several functions are available for making color objects:

\begin{itemize}
\item {\tt gray(x)} returns a shade of gray. The argument $x$ should be in the range 0--1. If $x=0$, black is returned; if $x=1$, white is returned.
\item {\tt rgb(r,g,b)} returns a color with the specified RGB components, which should be in the range 0--1.
\item {\tt cmyk(c,m,y,k)} returns a color with the specified CMYK components, which should be in the range 0--1.
\item {\tt hsb(h,s,b)} returns a color with the specified coordinates in hue--saturation--brightness color space, which should be in the range 0--1.
\end{itemize}

\noindent In addition, color objects corresponding to all of PyXPlot's built-in
named colors can be found in the {\tt colors} module.

\begin{verbatim}
a = colors.red
b = rgb(0,0.5,0)
box from 0,0 to 3,3 with color a fillcolor b lw 5
\end{verbatim}

Once a color object has been made, various operations are supported.
Multiplying or dividing a color by a number changes the brightness of the
color. When two colors are compared, brighter colors are greater than darker
colors. When two colors are added together, they are additively mixed in RGB
space, so that adding red and green together produces yellow. When one color is
subtracted from another, the opposite happens, so that yellow minus green is
red.

\noindent The methods available on {\tt color} objects are listed in
Section~\ref{sec:color_methods}.

\subsection{Color representations of the electromagnetic spectrum}

Two functions, in the {\tt colors} module, provide color objects which
approximate the color of particular wavelengths of light, or of electromagnetic
spectra.

\funcdef{colors.wavelength($\lambda$,$norm$)}{returns a color representation of monochromatic light at wavelength $\lambda$, normalised to brightness $norm$. A value of $norm=1$ is recommended for plotting the complete span of the electromagnetic spectrum without colors clipping to white.}
\funcdef{colors.spectrum($spec,norm$)}{returns a color representation of the spectrum $spec$, normalised to brightness $norm$. $spec$ should be a function object that takes a single input (wavelength) with units of length, and may return an output with arbitrary units.}

\noindent For an example of the use of these functions, see
Section~\ref{sec:colormaps}.

\section{Dates}

\section{Modules and classes}

\section{File handles}

File handles provide a means of reading data directly from text files in
PyXPlot scripts, or of writing data to files. Files are opened using the {\tt
open()} function:

\vspace{2mm}
\funcdef{open($x$[,$y$])}{opens the file $x$ with string access mode $y$, and returns a file handle object.}
\vspace{4mm}

\noindent The most commonly used access modes are {\tt "r"}, to open a file read-only, {\tt "w"}, to open a file for writing, erasing any pre-existing file of the same filename, and {\tt "a"}, to append data to the end of a file.

Alternatively, if what is wanted is a temporary scratch space, the {\tt os.tmpfile()} function should be used:

\vspace{2mm}
\funcdef{os.tmpfile()}{returns a file handle for a temporary file.}
\vspace{4mm}

\noindent The resulting file handle is open for both reading and writing.

The following methods are defined for file handles:

\methdef{close()}{closes a file handle.}
\methdef{eof()}{returns a boolean flag to indicate whether the end of a file has been reached.}
\methdef{flush()}{flushes any buffered data which has not yet physically been written to a file.}
\methdef{getPos()}{returns a file handle's current position in a file.}
\methdef{isOpen()}{returns a boolean flag indicating whether a file is open.}
\methdef{read()}{returns the contents of a file as a string.}
\methdef{readline()}{returns a single line of a file as a string.}
\methdef{readlines()}{returns the lines of a file as a list of strings.}
\methdef{setPos($x$)}{sets a file handle's current position in a file.}
\methdef{write($x$)}{writes the string $x$ to a file.}

